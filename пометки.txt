Что такое колбэк (callback)?
Колбэк — это функция, передаваемая в другую функцию в качестве аргумента, чтобы быть вызванной позже, когда завершится какая-то операция. продолжает выполнять код, а результат обрабатывается позже, через колбэк.
Когда нужно выполнить несколько асинхронных операций последовательно, код начинает «врастать вправо»

Недостатки такого кода:

Плохая читаемость: сложно понять последовательность действий.
Сложность в отладке: трудно отследить, где именно возникла ошибка.
Нет единой обработки ошибок: ошибка в каждом колбэке надо обрабатывать отдельно.
Трудно повторно использовать логику — всё «склеено» в одну цепочку.

Колбэки показывают идею асинхронности, но не обеспечивают удобного управления ею.
Следующий шаг — Promise: объект, представляющий будущий результат, и позволяющий писать цепочки без вложенности.


Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат. 
Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript, поэтому нам не нужно их писать. Нам нужно лишь позаботиться, чтобы исполнитель вызвал одну из них по готовности. Наш код – только внутри исполнителя.

Исполнитель должен вызвать что-то одно: resolve или reject. Состояние промиса может быть изменено только один раз.

Все последующие вызовы resolve и reject будут проигнорированы
Если мы заинтересованы только в результате успешного выполнения задачи, то в then можно передать только одну функцию

цепочка промисов
Идея состоит в том, что результат первого промиса передаётся по цепочке обработчиков .then.

Найди ошибку
Мы добавили несколько обработчиков к одному промису. Они не передают друг другу результаты своего выполнения, а действуют независимо.
Все обработчики .then на одном и том же промисе получают одно и то же значение – результат выполнения того же самого промиса. Таким образом, в коде выше все alert показывают одно и то же: 1.
На практике весьма редко требуется назначать несколько обработчиков одному промису. А вот цепочка промисов используется куда чаще.

Поток выполнения такой:

Начальный промис успешно выполняется, затем вызывается 2-й обработчик в .then  и т.д.
Всё это работает, потому что вызов promise.then тоже возвращает промис, так что мы можем вызвать на нём следующий .then.
Когда обработчик возвращает какое-то значение, то оно становится результатом выполнения соответствующего промиса и передаётся в следующий .then

async/wait
У слова async один простой смысл: эта функция всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически.
Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.

Когда промис завершается успешно, await promise возвращает результат. Когда завершается с ошибкой – будет выброшено исключение.
Но есть нюанс: на практике промис может завершиться с ошибкой не сразу, а через некоторое время. В этом случае будет задержка, а затем await выбросит исключение.
Такие ошибки можно ловить, используя try..catch

