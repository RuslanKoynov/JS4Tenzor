JavaScript — однопоточный язык, но часто нам нужно выполнять операции, которые ждут данные. Представь, что твой код должен получить данные с сервера, прочитать файл или просто выполнить действие с задержкой (например, setTimeout). Эти операции не мгновенны.
Если JavaScript будет ждать их завершения, он "заморозит" интерфейс и браузер “зависнет”. Чтобы этого избежать, используются асинхронные операции.
В этом уроке мы разберём две конструкции - promise и async/await


# Promise — основы
Промис (Promise) – это специальный объект, который представляет собой "обещание" предоставить результат (успешный или с ошибкой) в будущем.

### Создание promise:
```javascript
let myPromise = new Promise(function (resolve, reject) => {
    // Асинхронная операция (например, запрос к API)
    setTimeout(() => {
        let success = Math.random() > 0.3; // Имитация успеха/ошибки
        if (success) {
            resolve("Данные успешно загружены!"); // Передаем результат
        } else {
            reject("Ошибка загрузки!"); // Передаем ошибку
        }
    }, 1000);
});
```
### Обработка результата promise (.then, .catch, .finally)
У promise есть внутренние свойства:
- `state` («состояние») — вначале `pending` («ожидание»), потом меняется на `fulfilled` («выполнено успешно») при вызове resolve или на `rejected` («выполнено с ошибкой») при вызове reject.
- `result` («результат») — вначале `undefined`, далее изменяется на `value` при вызове resolve(value) или на `error` при вызове reject(error).

тут картинка

Свойства `state` и `result` – это внутренние свойства объекта promise и мы не имеем к ним прямого доступа. Чтобы получить результат (или ошибку) из promise, мы "подписываемся" на него с помощью методов:
- `.then(onFulfilled, onRejected)` – вызывается при успешном выполнении.
- `.catch(onRejected)` – вызывается при ошибке (лучшая практика – использовать его).
- `.finally(callback)` – вызывается в любом случае (для очистки).

```javascript
myPromise
    .then((result) => { // Сработает при вызове resolve()
        console.log("Успех:", result);
        return result + " Дополнительная обработка."; // Можно вернуть значение для следующего .then
    })
    .then((processedResult) => { // Цепочка промисов!
        console.log("Обработанный результат:", processedResult);
    })
    .catch((error) => { // Сработает при вызове reject() или ошибке в любом .then
        console.error("Произошла ошибка:", error);
    })
    .finally(() => {
        console.log("Операция с промисом завершена (успех или ошибка).");
    });
```

### Цепочка promise
promise можно соединять в цепочку. Каждый .then() может возвращать новый промис.

```javascript
fetch('/api/user')
  .then(response => response.json())
  .then(user => fetch(`/api/user/${user.id}/posts`))
  .then(postsResponse => postsResponse.json())
  .then(posts => console.log(posts))
  .catch(err => console.error("Что-то пошло не так:", err));
```

Это избавляет от "callback hell", но читаемость всё ещё не идеальна…

# async/await

Работа с цепочками .then() может стать громоздкой. Ключевые слова async и await позволяют писать асинхронный код так, как если бы он был синхронным.

### Правила:

- `async` ставится перед функцией. Это означает, что функция всегда возвращает Промис.
- await можно использовать только внутри async-функций. Он заставляет интерпретатор JavaScript ждать, пока Промис справа от await не выполнится. Код приостанавливается, но не блокирует основной поток.

Перепишем пример с колбэками на async/await:
(Предположим, что getUserData, getPosts теперь возвращают promise).

```javascript
async function fetchUserData() {
    try {
        const user = await getUserData(); // Ждем результата промиса
        const posts = await getPosts(user.id); // Ждем, используя результат предыдущего шага
        const comments = await getComments(posts[0].id);
        console.log(comments);
    } catch (error) {
        // catch перехватит ошибку из ЛЮБОГО await в этом блоке try
        console.error("Ошибка в цепочке запросов:", error);
    } finally {
        console.log("Запрос данных завершен.");
    }
}

fetchUserData(); // Вызов async-функции вернет Промис.
```

Ключевые преимущества async/await:

- Код чище и линейнее, похож на синхронный.
- Ошибки ловятся привычным try...catch.
- Удобная работа с циклами и условиями.

## Важно помнить:

- `await` можно использовать только внутри async-функций (кроме top-level await в модулях).
- Не забывайте обрабатывать ошибки с помощью try...catch.
- Параллельное выполнение: если promise не зависят друг от друга, используйте Promise.all().

```javascript
async function fetchParallel() {
    const [user, news] = await Promise.all([ // Ждем массив результатов
        getUserData(),
        getNewsFeed()
    ]);
    console.log(user, news);
}
```
# Заключение:

1. Промис (Promise) – это фундаментальный объект для работы с асинхронностью.
2. async/await – современный и удобный синтаксис для работы с promise, основанный на них же.
3. Всегда обрабатывайте возможные ошибки с помощью .catch() или try...catch.

# Практическое упражнение:
Напиши небольшую функцию getData(url), которая использует fetch() (возвращает Промис) и async/await, чтобы получить данные по URL и вывести их в консоль. Не забудь про обработку ошибок.
